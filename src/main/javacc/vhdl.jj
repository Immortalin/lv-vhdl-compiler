/**
 *
 * VHDL-93, VHDL-AMS grammar for JavaCC
 * (c) 1997 Christoph Grimm
 *
 * EMail: grimm@ti.informatik.uni-frankfurt.de
 * Address:
 * Christoph Grimm
 * J. W. Goethe-University Frankfurt
 * Robert-Mayer-Strasse 11-15
 * 60054 Frankfurt
 * Germany
 *
 *
 * By using this file, I agree with the following:
 * -----------------------------------------------
 *
 * 1. This grammar is free for evaluation purposes.
 *
 * 2. You may use and modify it, but when distributing is, you must also
 *    include the original files and copyright notes from me.
 *
 * 3. For commercial use of derived works contact me.
 *
 * 4. The grammar is NOT optimized for speed. The aim is to keep the grammar
 *    similar to the original productions in the LRM.
 *
 * 5. Don't complain about errors - report them, maybe with fixes to me.
 *
 */

options
{
  STATIC=false;
}

PARSER_BEGIN(VHDL93Parser)

package stupaq.vhdl93;

import stupaq.vhdl93.errors.*;

public class VHDL93Parser
{
  private ErrorHandler errorHandler;

  public void setErrorHandler(ErrorHandler handler) {
    errorHandler = handler;
  }

  public ErrorHandler getErrorHandler() {
    return errorHandler;
  }
}

PARSER_END(VHDL93Parser)

/** LEXICAL ELEMENTS */
SKIP :
{
    " "
  | "\n"
  | "\r"
  | "\t"
}

SPECIAL_TOKEN :
{
  <COMMENT: "--" ( ~["\n","\r"] )* ( "\n"|"\r"|"\r\n" )>
}

TOKEN [IGNORE_CASE] :
{
    <ABS:           "abs">
  | <ACCESS:        "access">
  | <ACROSS:        "across">
  | <AFTER:         "after">
  | <ALIAS:         "alias">
  | <ALL:           "all">
  | <AND:           "and">
  | <ARCHITECTURE:  "architecture">
  | <ARRAY:         "array">
  | <ASSERT:        "assert">
  | <ATTRIBUTE:     "attribute">
  | <BEGIN:         "begin">
  | <BLOCK:         "block">
  | <BODY:          "body">
  | <BREAK:         "break">
  | <BUFFER:        "buffer">
  | <BUS:           "bus">
  | <CASE:          "case">
  | <COMPONENT:     "component">
  | <CONFIGURATION: "configuration">
  | <CONSTANT:      "constant">
  | <DISCONNECT:    "disconnect">
  | <DOWNTO:        "downto">
  | <ELSE:          "else">
  | <ELSIF:         "elsif">
  | <END:           "end">
  | <ENTITY:        "entity">
  | <EXIT:          "exit">
  | <FILE:          "file">
  | <FOR:           "for">
  | <FUNCTION:      "function">
  | <GENERATE:      "generate">
  | <GENERIC:       "generic">
  | <GROUP:         "group">
  | <GUARDED:       "guarded">
  | <IF:            "if">
  | <IMPURE:        "impure">
  | <IN:            "in">
  | <INERTIAL:      "inertial">
  | <INOUT:         "inout">
  | <IS:            "is">
  | <LABEL:         "label">
  | <LIBRARY:       "library">
  | <LINKAGE:       "linkage">
  | <LITERAL:       "literal">
  | <LOOP:          "loop">
  | <MAP:           "map">
  | <MOD:           "mod">
  | <NAND:          "nand">
  | <NEW:           "new">
  | <NEXT:          "next">
  | <NOISE:         "noise">
  | <NOR:           "nor">
  | <NOT:           "not">
  | <NULL:          "null">
  | <OF:            "of">
  | <ON:            "on">
  | <OPEN:          "open">
  | <OR:            "or">
  | <OTHERS:        "others">
  | <OUT:           "out">
  | <PACKAGE:       "package">
  | <PORT:          "port">
  | <POSTPONED:     "postponed">
  | <PROCEDURAL:    "procedural">
  | <PROCEDURE:     "procedure">
  | <PROCESS:       "process">
  | <PURE:          "pure">
  | <QUANTITY:      "quantity">
  | <RANGE:         "range">
  | <RECORD:        "record">
  | <REGISTER:      "register">
  | <REJECT:        "reject">
  | <REM:           "rem">
  | <REPORT:        "report">
  | <RETURN:        "return">
  | <ROL:           "rol">
  | <ROR:           "ror">
  | <SELECT:        "select">
  | <SEVERITY:      "severity">
  | <SIGNAL:        "signal">
  | <SHARED:        "shared">
  | <SLA:           "sla">
  | <SLL:           "sll">
  | <SPECTRUM:      "spectrum">
  | <SRA:           "sra">
  | <SRL:           "srl">
  | <SUBTYPE:       "subtype">
  | <TERMINAL:      "terminal">
  | <THEN:          "then">
  | <THROUGH:       "through">
  | <TO:            "to">
  | <TOLERANCE:     "tolerance">
  | <TRANSPORT:     "transport">
  | <TYPE:          "type">
  | <UNAFFECTED:    "unaffected">
  | <UNITS:         "units">
  | <UNTIL:         "until">
  | <USE:           "use">
  | <VARIABLE:      "variable">
  | <WAIT:          "wait">
  | <WHEN:          "when">
  | <WHILE:         "while">
  | <WITH:          "with">
  | <XNOR:          "xnor">
  | <XOR:           "xor">
}

TOKEN:
{
  <character_literal:       "'" (" ")* ( <graphic_character> | "\"" ) (" ")* "'">
}

TOKEN [IGNORE_CASE] :
{
    <#digit:                ["0"-"9"]>
  | <#hex_digit:            ["0"-"9", "A"-"F"]>

  | <#integer:              <digit> ( ("_" )? <digit> )*>
  | <#base:                 <integer> >
  | <#based_integer:        ( ("_")? <hex_digit> )*>
  | <#exponent:             ( "E" ("+")? <integer> ) | ( "E" "-" <integer> )>
  | <based_literal:         <base> "#" <based_integer> ( "." <based_integer> )? "#" ( <exponent> )?>
  | <decimal_literal:       <integer> ( "." <integer> )? ( <exponent> )?>

  | <#base_specifier:       ["B", "O", "X"]>
  | <#bit_value:            <hex_digit> ( ( "_" )* <hex_digit> )*>
  | <bit_string_literal:    <base_specifier> "\"" <bit_value> "\"">

  | <#letter:               ["a"-"z", "A"-"Z"]>
  | <#letter_or_digit:      ["a"-"z", "A"-"Z", "0"-"9"]>
  | <basic_identifier:      <letter> ( ( "_" )? <letter_or_digit> )*>

  | <#special_character:    ["#","&","'","(",")","*","+",",","-",".","/",":",";","<","=",">","[","]","_","|","!","$","%","@","?","^","`","{","}","~"," ","\u00a0"-"\uffff"]>
  | <#format_effector:      ["\n","\t","\b","\f","\r"]>
  | <#egraphic_character:   ( <letter_or_digit> | <special_character> | <format_effector> )>
  | <#graphic_character:    ( <egraphic_character> | "\\" )>

  | <extended_identifier:   "\\" ( <egraphic_character> | "\\\\" ) ( ( <egraphic_character> | "\\\\" ) )* "\\">

  | <string_literal:        "\"" ( <graphic_character> | "\"\"" )* "\"">

  | <EXP:       "**">
  | <MUL:       "*">
  | <DIV:       "/">
  | <ADD:       "+">
  | <SUB:       "-">
  | <CONCAT:    "&">
  | <EQ:        "=">
  | <NEQ:       "/=">
  | <GE:        ">=">
  | <LE:        "<=">
  | <GT:        ">">
  | <LO:        "<">
  | <SEMICOLON: ";">
  | <COMMA:     ",">
  | <COLON:     ":">
  | <BOX:       "<>">
  | <TICK:      "'">
  | <LPAREN:    "(">
  | <RPAREN:    ")">
  | <LBRACKET:  "[">
  | <RBRACKET:  "]">
  | <ASSIGN:    ":=">
  | <PERIOD:    ".">
  | <FOLLOWS:   "=>">
  | <PIPE:      "|">
  | <LBRACE:    "{">
  | <RBRACE:    "}">
}
/** /LEXICAL ELEMENTS */

/** TYPES */
void access_type_definition() :
{}
{
  <ACCESS> subtype_indication()
}

void array_type_definition() :
{}
{
    LOOKAHEAD( unconstrained_array_definition() ) unconstrained_array_definition()
  | constrained_array_definition()
}

void composite_type_definition() :
{}
{
    array_type_definition()
  | record_type_definition()
}

void element_subtype_definition() :
{}
{
  subtype_indication()
}

void enumeration_type_definition() :
{}
{
  <LPAREN> enumeration_literal() ( <COMMA> enumeration_literal() )* <RPAREN>
}

void file_type_definition() :
{}
{
  <FILE> <OF> type_mark()
}

void floating_type_definition() :
{}
{
  range_constraint()
}

void full_type_declaration() :
{}
{
  <TYPE> identifier() <IS> type_definition() <SEMICOLON>
}

void incomplete_type_declaration() :
{}
{
  <TYPE> identifier() <SEMICOLON>
}

void index_subtype_definition() :
{}
{
  type_mark() <RANGE> <BOX>
}

void integer_type_definition() :
{}
{
  range_constraint()
}

void physical_type_definition() :
{}
{
  range_constraint()
  <UNITS>
    base_unit_declaration()
    ( secondary_unit_declaration() )*
  <END> <UNITS> [ physical_type_simple_name() ]
}

void record_type_definition() :
{}
{
  <RECORD>
    ( element_declaration() )+
  <END> <RECORD> [ record_type_simple_name() ]
}

void scalar_type_definition() :
{}
{
    LOOKAHEAD( range_constraint() <UNITS> ) physical_type_definition()
  | LOOKAHEAD( enumeration_type_definition() ) enumeration_type_definition()
  | range_constraint()
}

void subtype_declaration() :
{}
{
  <SUBTYPE> identifier() <IS> subtype_indication() <SEMICOLON>
}

void subtype_indication() :
{}
{
    LOOKAHEAD( resolution_function_name() type_mark() constraint() ) resolution_function_name() type_mark() constraint()
  | LOOKAHEAD( type_mark() constraint() ) type_mark() constraint()
  | LOOKAHEAD( resolution_function_name() type_mark() ) resolution_function_name() type_mark()
  | LOOKAHEAD( type_mark() ) type_mark()
}

void type_conversion() :
{}
{
  type_mark() <LPAREN> expression() <RPAREN>
}

void type_declaration() :
{}
{
    LOOKAHEAD( <TYPE> identifier() <IS> )
    full_type_declaration()
  | incomplete_type_declaration()
}

void type_definition() :
{}
{
    scalar_type_definition()
  | composite_type_definition()
  | access_type_definition()
  | file_type_definition()
}

void type_mark() :
{}
{
  type_name()
}

void unconstrained_array_definition() :
{}
{
  <ARRAY> <LPAREN> index_subtype_definition() ( <COMMA> index_subtype_definition() )* <RPAREN> <OF> element_subtype_indication()
}
/** /TYPES */

void abstract_literal() :
{}
{
    <decimal_literal>
  | <based_literal>
}

void actual_designator() :
{}
{
    LOOKAHEAD( expression() )
    expression()
  | LOOKAHEAD( signal_name() )
    signal_name()
  | LOOKAHEAD( variable_name() )
    variable_name()
  | LOOKAHEAD( file_name() )
    file_name()
  | <OPEN>
}

void actual_parameter_part() :
{}
{
  parameter_association_list()
}

void actual_part() :
{}
{
    LOOKAHEAD( function_name() <LPAREN> actual_designator() <RPAREN> )
    function_name() <LPAREN> actual_designator() <RPAREN>
  | LOOKAHEAD( type_mark() <LPAREN> actual_designator() <RPAREN> )
    type_mark() <LPAREN> actual_designator() <RPAREN>
  | actual_designator()
}

void adding_operator() :
{}
{
    <ADD>
  | <SUB>
  | <CONCAT>
}

void aggregate() :
{}
{
  <LPAREN> element_association() ( <COMMA> element_association() )* <RPAREN>
}

void alias_declaration() :
{}
{
  <ALIAS> alias_designator() [ <COLON> subtype_indication() ] <IS> name() signature() <SEMICOLON>
}

void alias_designator() :
{}
{
    identifier()
  | <character_literal>
  | operator_symbol()
}

void allocator() :
{}
{
  <NEW>
  (
      LOOKAHEAD( type_mark() <TICK> )
      qualified_expression()
    | subtype_indication()
  )
}

void architecture_body() :
{}
{
  <ARCHITECTURE> identifier() <OF> entity_name() <IS>
    architecture_declarative_part()
  <BEGIN>
    architecture_statement_part()
  <END> [ <ARCHITECTURE> ] [ architecture_simple_name() ] <SEMICOLON>
}

void architecture_declarative_part() :
{}
{
  ( block_declarative_item() )*
}

void architecture_statement_part() :
{}
{
  ( architecture_statement() )*
}

void architecture_statement() :
{}
{
  // TODO error recovery to next SEMICOLON
    LOOKAHEAD( [block_label() <COLON>] <BLOCK> )
    block_statement()
  | LOOKAHEAD( [process_label() <COLON>] [<POSTPONED>] <PROCESS> )
    process_statement()
  | LOOKAHEAD( [label() <COLON>] [<POSTPONED>] procedure_call() <SEMICOLON> )
    concurrent_procedure_call_statement()
  | LOOKAHEAD( [label() <COLON>] [<POSTPONED>] <ASSERT> )
    concurrent_assertion_statement()
  | LOOKAHEAD( [label() <COLON>] [<POSTPONED>] conditional_signal_assignment()|
              [label() <COLON>] [<POSTPONED>] selected_signal_assignment() )
    concurrent_signal_assignment_statement()
  | LOOKAHEAD( instantiation_label() <COLON> instantiated_unit() )
    component_instantiation_statement()
  | LOOKAHEAD( generate_statement() )
    generate_statement()
}

void assertion() :
{}
{
  <ASSERT> condition()
  [ <REPORT> expression() ]
  [ <SEVERITY> expression() ]
}

void assertion_statement() :
{}
{
  [ label() <COLON> ] assertion() <SEMICOLON>
}

void association_element() :
{}
{
  [ LOOKAHEAD( formal_part() <FOLLOWS> ) formal_part() <FOLLOWS> ]
  actual_part()
}

void association_list() :
{}
{
  association_element() ( <COMMA> association_element() )*
}

void attribute_declaration() :
{}
{
  <ATTRIBUTE> identifier() <COLON> type_mark() <SEMICOLON>
}

void attribute_designator() :
{}
{
  attribute_simple_name()
}

void attribute_name() :
{}
{
  prefix() signature() <TICK> attribute_designator() [ <LPAREN> expression() ( <COMMA> expression() )* <RPAREN> ]
}

void attribute_specification() :
{}
{
  <ATTRIBUTE> attribute_designator() <OF>
  entity_specification() <IS> expression() <SEMICOLON>
}

void base_unit_declaration() :
{}
{
  identifier() <SEMICOLON>
}

void binding_indication() :
{}
{
  [ <USE> entity_aspect() ]
  [ generic_map_aspect() ]
  [ port_map_aspect() ]
}

void block_configuration() :
{}
{
  <FOR> block_specification()
                ( use_clause() )*
                ( configuration_item() )*
  <END> <FOR> <SEMICOLON>
}

void block_declarative_item() :
{}
{
  // TODO error recovery to next SEMICOLON
    LOOKAHEAD( subprogram_declaration() )
    subprogram_declaration()
  | subprogram_body()
  | type_declaration()
  | subtype_declaration()
  | constant_declaration()
  | signal_declaration()
  | shared_variable_declaration()
  | file_declaration()
  | alias_declaration()
  | component_declaration()
  | LOOKAHEAD( attribute_declaration() )
    attribute_declaration()
  | attribute_specification()
  | configuration_specification()
  | disconnection_specification()
  | use_clause()
  | LOOKAHEAD( <GROUP> identifier() <IS> )
    group_template_declaration()
  | group_declaration()
}

void block_declarative_part() :
{}
{
  ( block_declarative_item() )*
}

void block_header() :
{}
{
  [ generic_clause()  [ generic_map_aspect() <SEMICOLON> ] ]
  [ port_clause()     [ port_map_aspect() <SEMICOLON>    ] ]
}

void block_specification() :
{}
{
    LOOKAHEAD( architecture_name() )
    architecture_name()
  | LOOKAHEAD( block_statement_label() )
    block_statement_label()
  | LOOKAHEAD( generate_statement_label() )
    generate_statement_label() [ <LPAREN> index_specification() <RPAREN> ]
}

void block_statement() :
{}
{
  block_label() <COLON>
                <BLOCK> [ <LPAREN> guard_expression() <RPAREN> ] [ <IS> ]
                        block_header()
                        block_declarative_part()
                <BEGIN>
                        block_statement_part()
                <END> <BLOCK> [ block_label() ] <SEMICOLON>
}

void block_statement_part() :
{}
{
  ( architecture_statement() )*
}

void case_statement() :
{}
{
  [ case_label() <COLON> ]
                <CASE> expression() <IS>
                        case_statement_alternative()
                        ( case_statement_alternative() )*
                <END> <CASE> [ case_label() ] <SEMICOLON>
}

void case_statement_alternative() :
{}
{
  <WHEN> choices() <FOLLOWS> sequence_of_statements()
}

void choice() :
{}
{
    LOOKAHEAD( simple_expression() )
    simple_expression()
  | LOOKAHEAD( discrete_range() )
    discrete_range()
  | element_simple_name()
  | <OTHERS>
}

void choices() :
{}
{
  choice() ( <PIPE> choice() )*
}

void component_configuration() :
{}
{
  <FOR> component_specification()
                [ binding_indication() <SEMICOLON> ]
                [ block_configuration() ]
  <END> <FOR> <SEMICOLON>
}

void component_declaration() :
{}
{
  <COMPONENT> identifier() [ <IS> ]
      [ local_generic_clause() ]
      [ local_port_clause() ]
  <END> <COMPONENT> [ component_simple_name() ] <SEMICOLON>
}

void component_instantiation_statement() :
{}
{
  instantiation_label() <COLON>
         instantiated_unit()
         [ generic_map_aspect() ]
         [ port_map_aspect() ] <SEMICOLON>
}

void component_specification() :
{}
{
  instantiation_list() <COLON> component_name()
}

void concurrent_assertion_statement() :
{}
{
  [ label() <COLON> ] [ <POSTPONED> ] assertion() <SEMICOLON>
}

void concurrent_procedure_call_statement() :
{}
{
  [ LOOKAHEAD( label() <COLON> ) label() <COLON> ]
  [ <POSTPONED> ] procedure_call() <SEMICOLON>
}

void concurrent_signal_assignment_statement() :
{}
{
  [ LOOKAHEAD( label() <COLON> ) label() <COLON> ] [ <POSTPONED> ]
  (
      LOOKAHEAD( target() <LE> options_() conditional_waveforms() <SEMICOLON> ) conditional_signal_assignment()
    | selected_signal_assignment()
  )
}

void condition() :
{}
{
  boolean_expression()
}

void condition_clause() :
{}
{
  <UNTIL> condition()
}

void conditional_signal_assignment() :
{}
{
  target() <LE> options_() conditional_waveforms() <SEMICOLON>
}

void conditional_waveforms() :
{}
{
  //( waveform() <WHEN> condition() <ELSE> )*
  //waveform() [ <WHEN> condition() ]
  waveform()
    ( LOOKAHEAD( <WHEN> condition() <ELSE> )
        <WHEN> condition() <ELSE> waveform() )*
    [ <WHEN> condition() ]
}

void configuration_declaration() :
{}
{
  <CONFIGURATION> identifier() <OF> entity_name() <IS>
    configuration_declarative_part()
    block_configuration()
  <END> [ <CONFIGURATION> ] [ configuration_simple_name() ] <SEMICOLON>
}

void configuration_declarative_item() :
{}
{
  // TODO error recovery to next SEMICOLON
    use_clause()
  | attribute_specification()
  | group_declaration()
}

void configuration_declarative_part() :
{}
{
  ( configuration_declarative_item() )*
}

void configuration_item() :
{}
{
    LOOKAHEAD( block_configuration() )
    block_configuration()
  | component_configuration()
}

void configuration_specification() :
{}
{
  <FOR> component_specification() binding_indication() <SEMICOLON>
}

void constant_declaration() :
{}
{
  <CONSTANT> identifier_list() <COLON> subtype_indication() [ <ASSIGN> expression() ] <SEMICOLON>
}

void constrained_array_definition() :
{}
{
  <ARRAY> index_constraint() <OF> element_subtype_indication()
}

void constraint() :
{}
{
    range_constraint()
  | index_constraint()
}

void context_clause() :
{}
{
  ( context_item() )*
}

void context_item() :
{}
{
    library_clause()
  | use_clause()
}

/** Section 4: Declarations */
void delay_mechanism() :
{}
{
    <TRANSPORT>
  | [ <REJECT> time_expression() ] <INERTIAL>
}

void design_file() :
{}
{
  ( design_unit() )+ <EOF>
}

void design_unit() :
{}
{
  context_clause() library_unit()
}

void designator() :
{}
{
    identifier()
  | operator_symbol()
}

void direction() :
{}
{
  <TO> | <DOWNTO>
}

void disconnection_specification() :
{}
{
  <DISCONNECT> guarded_signal_specification() <AFTER>
    time_expression() <SEMICOLON>
}

void discrete_range()  :
{}
{
    LOOKAHEAD( simple_expression() direction() )
    range()
  | LOOKAHEAD( discrete_subtype_indication() )
    discrete_subtype_indication()
  | range()
}

void element_association() :
{}
{
  [ LOOKAHEAD( choices() <FOLLOWS> ) choices() <FOLLOWS> ]
  expression()
}

void element_declaration() :
{}
{
  identifier_list() <COLON> element_subtype_definition() <SEMICOLON>
}

void entity_aspect() :
{}
{
    <ENTITY> entity_name()
    [ LOOKAHEAD( <LPAREN> architecture_identifier() <RPAREN> )
    <LPAREN> architecture_identifier() <RPAREN> ]
  | <CONFIGURATION> configuration_name()
  | <OPEN>
}

void shared_variable_declaration() :
{}
{
  [ <SHARED> ] <VARIABLE> identifier_list() <COLON> subtype_indication() [ <ASSIGN> expression() ] <SEMICOLON>
}

/** Section 5: Specifications */
void entity_class() :
{}
{
    <ENTITY>
  | <ARCHITECTURE>
  | <CONFIGURATION>
  | <PROCEDURE>
  | <FUNCTION>
  | <PACKAGE>
  | <TYPE>
  | <SUBTYPE>
  | <CONSTANT>
  | <SIGNAL>
  | <VARIABLE>
  | <COMPONENT>
  | <LABEL>
  | <LITERAL>
  | <UNITS>
  | <GROUP>
  | <FILE>
}

void entity_class_entry()  :
{}
{
  entity_class() [ <BOX> ]
}

void entity_class_entry_list() :
{}
{
  entity_class_entry() ( <COMMA> entity_class_entry() )*
}

void entity_declaration() :
{}
{
  <ENTITY> identifier() <IS> entity_header()
    entity_declarative_part()
  [ <BEGIN> entity_statement_part() ]
  <END> [ <ENTITY> ] [ entity_simple_name() ] <SEMICOLON>
}

void entity_declarative_item() :
{}
{
  // TODO error recovery to next SEMICOLON
    LOOKAHEAD( subprogram_declaration() )
    subprogram_declaration()
  | subprogram_body()
  | type_declaration()
  | subtype_declaration()
  | constant_declaration()
  | signal_declaration()
  | shared_variable_declaration()
  | file_declaration()
  | alias_declaration()
  | LOOKAHEAD( attribute_declaration() )
    attribute_declaration()
  | attribute_specification()
  | disconnection_specification()
  | use_clause()
  | LOOKAHEAD( <GROUP> identifier() <IS> )
    group_template_declaration()
  | group_declaration()
}

void entity_declarative_part() :
{}
{
  ( entity_declarative_item() )*
}

void entity_designator() :
{}
{
  entity_tag() signature()
}

void entity_header() :
{}
{
  [ formal_generic_clause() ]
  [ formal_port_clause() ]
}

void entity_name_list() :
{}
{
  entity_designator() ( <COMMA> entity_designator() )*
  | <OTHERS>
  | <ALL>
}

void entity_specification() :
{}
{
        entity_name_list() <COLON> entity_class()
}

void entity_statement() :
{}
{   LOOKAHEAD( concurrent_assertion_statement() )
    concurrent_assertion_statement()
  | LOOKAHEAD( [process_label() <COLON>] [<POSTPONED>] <PROCESS> )
    passive_process_statement()
  | passive_concurrent_procedure_call_statement()
}

void entity_statement_part() :
{}
{
  ( entity_statement() )*
}

void entity_tag() :
{}
{
    simple_name()
  | <character_literal>
  | operator_symbol()
}

void enumeration_literal() :
{}
{
  <character_literal>
  | identifier()
}

void exit_statement() :
{}
{
  [ label() <COLON> ] <EXIT> [ loop_label() ]
    [ <WHEN> condition() ] <SEMICOLON>
}

void expression() :
{}
{
/**  relation() (
 *   ( <AND> relation() )* |
 *    ( <OR> relation() )*  |
 *    ( <XOR> relation() )* |
 *    [ <NAND> relation() ] |
 *    [ <NOR> relation() ]  |
 *    ( <XNOR> relation() )*
 *  )
 */
  relation() ( LOOKAHEAD( 1 ) logical_operator() relation() )*
}

void factor() :
{}
{
    <ABS> primary()
  | <NOT> primary()
  | primary() [ LOOKAHEAD( <EXP> primary() ) <EXP> primary() ]
}

void file_declaration() :
{}
{
  <FILE> identifier_list() <COLON> subtype_indication()
     [ file_open_information() ] <SEMICOLON>
}

void file_logical_name() :
{}
{
  string_expression()
}

void file_open_information() :
{}
{
  [ <OPEN> file_open_kind_expression() ] <IS> file_logical_name()
}

void formal_designator() :
{}
{
    LOOKAHEAD( generic_name() )
    generic_name()
  | LOOKAHEAD( port_name() )
    port_name()
  | parameter_name()
}

void formal_parameter_list() :
{}
{
  parameter_interface_list()
}

void formal_part() :
{}
{
    LOOKAHEAD( function_name() <LPAREN> formal_designator() <RPAREN> )
    function_name() <LPAREN> formal_designator() <RPAREN>
  | LOOKAHEAD( type_mark() <LPAREN> formal_designator() <RPAREN> )
    type_mark() <LPAREN> formal_designator() <RPAREN>
  | formal_designator()
}

void function_call() :
{}
{
  function_name()
  [ LOOKAHEAD( <LPAREN> actual_parameter_part() <RPAREN> ) <LPAREN> actual_parameter_part() <RPAREN> ]
}

/** Section 9.7 */
void generate_statement() :
{}
{
  generate_label() <COLON>
  generation_scheme() <GENERATE>
    [ LOOKAHEAD( 2 ) ( block_declarative_item() )* <BEGIN> ]
    ( architecture_statement() )*
  <END> <GENERATE> [ generate_label() ] <SEMICOLON>
}

void generation_scheme() :
{}
{
    <FOR> generate_parameter_specification()
  | <IF> condition()
}

void generic_clause() :
{}
{
  <GENERIC> <LPAREN> generic_list() <RPAREN> <SEMICOLON>
}

void generic_list() :
{}
{
  generic_interface_list()
}

void generic_interface_list() :
{}
{
  interface_constant_declaration() ( <SEMICOLON> interface_constant_declaration() )*
}

void generic_map_aspect() :
{}
{
  <GENERIC> <MAP> <LPAREN> generic_association_list() <RPAREN>
}

void group_constituent() :
{}
{
    name()
  | <character_literal>
}

void group_constituent_list() :
{}
{
  group_constituent() ( <COMMA> group_constituent() )*
}

void group_template_declaration() :
{}
{
  <GROUP> identifier() <IS> <LPAREN> entity_class_entry_list() <RPAREN> <SEMICOLON>
}

void group_declaration() :
{}
{
  <GROUP> identifier() <COLON> group_template_name()
  <LPAREN> group_constituent_list() <RPAREN> <SEMICOLON>
}

void guarded_signal_specification() :
{}
{
  guarded_signal_list() <COLON> type_mark()
}

void identifier() :
{}
{
    <basic_identifier>
  | <extended_identifier>
}

void identifier_list() :
{}
{
  identifier() ( <COMMA> identifier() )*
}

void if_statement() :
{}
{
  [ if_label() <COLON> ]
  <IF> condition() <THEN>
  sequence_of_statements()
  ( <ELSIF> condition() <THEN>
    sequence_of_statements() )*
  [ <ELSE>
    sequence_of_statements() ]
  <END> <IF> [ if_label() ] <SEMICOLON>
}

void index_constraint() :
{}
{
  <LPAREN> discrete_range() ( <COMMA> discrete_range() )* <RPAREN>
}

void index_specification() :
{}
{
    LOOKAHEAD( discrete_range() )
    discrete_range()
  | static_expression()
}

void indexed_name() :
{}
{
  prefix() <LPAREN> expression() ( <COMMA> expression() )* <RPAREN>
}

void instantiated_unit() :
{}
{
    [ <COMPONENT> ] component_name()
  | <ENTITY> entity_name() [ <LPAREN> architecture_identifier() <RPAREN> ]
  | <CONFIGURATION> configuration_name()
}

void instantiation_list() :
{}
{
    instantiation_label() ( <COMMA> instantiation_label() )*
  | <OTHERS>
  | <ALL>
}

void interface_constant_declaration() :
{}
{
  [ <CONSTANT> ] identifier_list() <COLON> [ <IN> ] subtype_indication() [ <ASSIGN> static_expression() ]
}

/** Section 4.3.2: */
void interface_declaration() :
{}
{
    LOOKAHEAD( interface_constant_declaration() )
    interface_constant_declaration()
  | LOOKAHEAD( interface_signal_declaration() )
    interface_signal_declaration()
  | LOOKAHEAD( interface_variable_declaration() )
    interface_variable_declaration()
  | LOOKAHEAD( interface_file_declaration() )
    interface_file_declaration()
}

void interface_element() :
{}
{
  interface_declaration()
}

void interface_file_declaration() :
{}
{
  <FILE> identifier_list() <COLON> subtype_indication()
}

void interface_list() :
{}
{
  interface_element() ( <SEMICOLON> interface_element() )*
}

void interface_signal_declaration() :
{}
{
  [<SIGNAL>] identifier_list() <COLON> [ mode() ] subtype_indication() [ <BUS> ] [ <ASSIGN> static_expression() ]
}

void interface_variable_declaration() :
{}
{
  [<VARIABLE>] identifier_list() <COLON> [ mode() ] subtype_indication() [ <ASSIGN> static_expression() ]
}

void iteration_scheme() :
{}
{
    <WHILE> condition()
  | <FOR> loop_parameter_specification()
}

void label() :
{}
{
  identifier()
}

void library_clause() :
{}
{
  <LIBRARY> logical_name_list() <SEMICOLON>
}

void library_unit() :
{}
{   LOOKAHEAD( <ENTITY> | <CONFIGURATION> | <PACKAGE> identifier() )
    primary_unit()
  | secondary_unit()
}

void literal() :
{}
{
    LOOKAHEAD( numeric_literal() ) numeric_literal()
  | enumeration_literal()
  | <string_literal>
  | <bit_string_literal>
  | <NULL>
}

void logical_name() :
{}
{
  identifier()
}

void logical_name_list() :
{}
{
  logical_name() ( <COMMA> logical_name() )*
}

void logical_operator() :
{}
{
    <AND>
  | <OR>
  | <NAND>
  | <NOR>
  | <XOR>
  | <XNOR>
}

void loop_statement() :
{}
{
  [ loop_label() <COLON> ]
  [ iteration_scheme() ] <LOOP>
                        sequence_of_statements()
  <END> <LOOP> [ loop_label() ] <SEMICOLON>
}

void miscellaneous_operator() :
{}
{
    <EXP>
  | <ABS>
  | <NOT>
}

void mode() :
{}
{
    <IN>
  | <OUT>
  | <INOUT>
  | <BUFFER>
  | <LINKAGE>
}

void multiplying_operator() :
{}
{
    <MUL>
  | <DIV>
  | <MOD>
  | <REM>
}

void name() :
{}
{
/**
 *    simple_name()
 *  | operator_symbol()
 *  | selected_name()
 *  | indexed_name()
 *  | slice_name()
 *  | attribute_name()
 */
  ( simple_name() | operator_symbol() )
  [ LOOKAHEAD( name_extension() ) name_extension()   ]
}

void name_extension() :
{}
{
  (
      LOOKAHEAD( signature() <TICK> ) signature() <TICK> attribute_designator() [ LOOKAHEAD( <LPAREN> expression() <RPAREN> ) <LPAREN> expression() <RPAREN> ]
    | <PERIOD> suffix()
    | LOOKAHEAD( <LPAREN> discrete_range() <RPAREN> ) <LPAREN> discrete_range() <RPAREN>
    | LOOKAHEAD( <LPAREN> expression() ( <COMMA> expression() )* <RPAREN> ) <LPAREN> expression() ( <COMMA> expression() )* <RPAREN>
  )
  [  LOOKAHEAD( name_extension() ) name_extension() ]
}

void next_statement() :
{}
{
  [ label() <COLON> ] <NEXT> [ loop_label() ] [ <WHEN> condition() ] <SEMICOLON>
}

void null_statement() :
{}
{
  [ label() <COLON> ] <NULL> <SEMICOLON>
}

void numeric_literal() :
{}
{
    LOOKAHEAD( physical_literal() ) physical_literal()
  | abstract_literal()
}

void object_declaration() :
{}
{
  // TODO error recovery to next SEMICOLON
    constant_declaration()
  | signal_declaration()
  | variable_declaration()
  | file_declaration()
}

void operator_symbol() :
{}
{
  <string_literal>
}

void options_() :
{}
{
  [ <GUARDED> ] [ delay_mechanism() ]
}

void package_body() :
{}
{
  <PACKAGE> <BODY> package_simple_name() <IS>
       package_body_declarative_part()
  <END> [ <PACKAGE> <BODY> ] [ package_simple_name() ] <SEMICOLON>
}

void package_body_declarative_item() :
{}
{
  // TODO error recovery to next SEMICOLON
    LOOKAHEAD( subprogram_declaration() )
    subprogram_declaration()
  | subprogram_body()
  | type_declaration()
  | subtype_declaration()
  | constant_declaration()
  | shared_variable_declaration()
  | file_declaration()
  | alias_declaration()
  | use_clause()
  | LOOKAHEAD( <GROUP> identifier() <IS> )
    group_template_declaration()
  | group_declaration()
}

void package_body_declarative_part() :
{}
{
  ( package_body_declarative_item() )*
}

void package_declaration() :
{}
{
  <PACKAGE> identifier() <IS>
    package_declarative_part()
  <END> [ <PACKAGE> ] [ package_simple_name() ] <SEMICOLON>
}

void package_declarative_item() :
{}
{
  // TODO error recovery to next SEMICOLON
    subprogram_declaration()
  | type_declaration()
  | subtype_declaration()
  | constant_declaration()
  | signal_declaration()
  | shared_variable_declaration()
  | file_declaration()
  | alias_declaration()
  | component_declaration()
  | LOOKAHEAD( attribute_declaration() )
    attribute_declaration()
  | attribute_specification()
  | disconnection_specification()
  | use_clause()
  | LOOKAHEAD( <GROUP> identifier() <IS> )
    group_template_declaration()
  | group_declaration()
}

void package_declarative_part() :
{}
{
  ( package_declarative_item() )*
}

void parameter_specification() :
{}
{
  identifier() <IN> discrete_range()
}

void physical_literal() :
{}
{
  [ LOOKAHEAD( abstract_literal() unit_name() ) abstract_literal() ] unit_name()
}

void port_clause() :
{}
{
  <PORT> <LPAREN> port_list() <RPAREN> <SEMICOLON>
}

void port_list() :
{}
{
  port_interface_list()
}

void port_interface_list() :
{}
{
  interface_signal_declaration() ( <SEMICOLON> interface_signal_declaration() )*
}

void port_map_aspect() :
{}
{
  <PORT> <MAP> <LPAREN> port_association_list() <RPAREN>
}

void prefix() :
{}
{
    LOOKAHEAD( function_call() )
    function_call()
  | name()
}

void primary() :
{}
{
    LOOKAHEAD( qualified_expression() )
    qualified_expression()
  | LOOKAHEAD( function_call() )
    function_call()
  | LOOKAHEAD( name() )
    name()
  | LOOKAHEAD( literal() )
    literal()
  | LOOKAHEAD( aggregate() )
    aggregate()
  | LOOKAHEAD( <LPAREN> expression() <RPAREN> )
    <LPAREN> expression() <RPAREN>
  | LOOKAHEAD( type_conversion() )
    type_conversion()
  | allocator()
}

void primary_unit() :
{}
{
    entity_declaration()
  | configuration_declaration()
  | LOOKAHEAD( <PACKAGE> identifier() )
    package_declaration()
}

void procedure_call() :
{}
{
  procedure_name() [ <LPAREN> actual_parameter_part() <RPAREN> ]
}

void procedure_call_statement() :
{}
{
   [ LOOKAHEAD( label() <SEMICOLON> ) label() <COLON> ]
   procedure_call() <SEMICOLON>
}

void process_declarative_item() :
{}
{
    LOOKAHEAD( subprogram_declaration() )
    subprogram_declaration()
  | subprogram_body()
  | type_declaration()
  | subtype_declaration()
  | constant_declaration()
  | variable_declaration()
  | file_declaration()
  | alias_declaration()
  | LOOKAHEAD( attribute_declaration() )
    attribute_declaration()
  | attribute_specification()
  | use_clause()
  | LOOKAHEAD( <GROUP> identifier() <IS> )
    group_template_declaration()
  | group_declaration()
}

void process_declarative_part() :
{}
{
  ( process_declarative_item() )*
}

void process_statement() :
{}
{
  [ process_label() <COLON> ] [ <POSTPONED> ] <PROCESS> [ <LPAREN> sensitivity_list() <RPAREN> ] [ <IS> ]
    process_declarative_part()
  <BEGIN>
    process_statement_part()
  <END> [ <POSTPONED> ] <PROCESS> [ process_label() ] <SEMICOLON>
}

void process_statement_part() :
{}
{
  ( sequential_statement() )*
}

void qualified_expression() :
{}
{
  type_mark() <TICK>
  (   LOOKAHEAD( aggregate() )
      aggregate()
    | <LPAREN> expression() <RPAREN>
  )
}

void range() :
{}
{
    LOOKAHEAD( simple_expression() direction() )
    range_attribute_value()
  | range_attribute_name()
}

void range_attribute_value() :
{}
{
  simple_expression() direction() simple_expression()
}

void range_constraint() :
{}
{
  <RANGE> range()
}

void relation() :
{}
{
  shift_expression() [ LOOKAHEAD( 1 ) relational_operator() shift_expression() ]
}

void relational_operator() :
{}
{
    <EQ>
  | <NEQ>
  | <LO>
  | <LE>
  | <GT>
  | <GE>
}

void report_statement() :
{}
{
  [ label() <COLON> ]  <REPORT> expression()
  [ <SEVERITY> expression() ] <SEMICOLON>
}

void return_statement() :
{}
{
  [ label() <COLON> ] <RETURN> [ expression() ] <SEMICOLON>
}

void secondary_unit() :
{}
{
    LOOKAHEAD( <ARCHITECTURE> ) architecture_body()
  | LOOKAHEAD( <PACKAGE> <BODY> ) package_body()
}

void secondary_unit_declaration() :
{}
{
  identifier() <EQ> physical_literal() <SEMICOLON>
}

void selected_name() :
{}
{
  /**
   * prefix() <PERIOD> suffix()
   * results in left-recursion...
   * the follwoing does the same ( i hope ... )
   */

  ( simple_name() | operator_symbol() )
  [ LOOKAHEAD( name_extension() )  name_extension() ]

  /**
   * semantic analysis has to ensure that last production
   * was <PERIOD> suffix()
   */
}

void selected_signal_assignment() :
{}
{
  <WITH> expression() <SELECT> target()  <LE> options_() selected_waveforms() <SEMICOLON>
}

void selected_waveforms() :
{}
{
  waveform() <WHEN> choices() ( <COMMA> waveform() <WHEN> choices() )*
}

void sensitivity_clause() :
{}
{
  <ON> sensitivity_list()
}

void sensitivity_list() :
{}
{
  signal_name() ( <COMMA> signal_name() )*
}

void sequence_of_statements() :
{}
{
  ( sequential_statement() )*
}

void sequential_statement() :
{}
{
  // TODO error recovery to next SEMICOLON
  (
    LOOKAHEAD( 3 )
    wait_statement()
  | LOOKAHEAD( 3 )
    assertion_statement()
  | LOOKAHEAD( 3 )
    report_statement()
  | LOOKAHEAD(  [ label() <COLON> ] target() <LE> )
    signal_assignment_statement()
  | LOOKAHEAD(  [ label() <COLON> ] target() <ASSIGN> )
    variable_assignment_statement()
  | LOOKAHEAD( 3 )
    procedure_call_statement()
  | LOOKAHEAD( 3 )
    if_statement()
  | LOOKAHEAD( 3 )
    case_statement()
  | LOOKAHEAD( 3 )
    loop_statement()
  | LOOKAHEAD( 3 )
    next_statement()
  | LOOKAHEAD( 3 )
    exit_statement()
  | LOOKAHEAD( 3 )
    return_statement()
  | LOOKAHEAD( 3 )
    null_statement()
  )
}

void shift_expression() :
{}
{
  simple_expression() [ LOOKAHEAD( 2 ) shift_operator() simple_expression()  ]
}

void shift_operator() :
{}
{
    <SLL>
  | <SRL>
  | <SLA>
  | <SRA>
  | <ROL>
  | <ROR>
}

void sign() :
{}
{
    <ADD>
  | <SUB>
}

void signal_assignment_statement() :
{}
{
  [ LOOKAHEAD( label() <COLON> ) label() <COLON> ] target() <LE> [ delay_mechanism() ] waveform() <SEMICOLON>
}

void signal_declaration() :
{}
{
  <SIGNAL> identifier_list() <COLON> subtype_indication() [ signal_kind() ] [ <ASSIGN> expression() ] <SEMICOLON>
}

void signal_kind() :
{}
{
    <REGISTER>
  | <BUS>
}

void signal_list() :
{}
{
    signal_name() ( <COMMA> signal_name() )*
  | <OTHERS>
  | <ALL>
}

void signature() :
{}
{
  [ type_mark() ( LOOKAHEAD( <COMMA> type_mark() ) <COMMA> type_mark() )* ]
  [ <RETURN> type_mark() ]
}

void simple_expression() :
{}
{
  [ sign() ] term() ( LOOKAHEAD( 2 ) adding_operator() term() )*
}

void simple_name() :
{}
{
  identifier()
}

void slice_name() :
{}
{
  prefix() <LPAREN> discrete_range() <RPAREN>
}

void subprogram_body() :
{}
{
  subprogram_specification() <IS>
    subprogram_declarative_part()
  <BEGIN>
    subprogram_statement_part()
  <END> [ subprogram_kind() ] [ designator() ] <SEMICOLON>
}

void subprogram_declaration() :
{}
{
  subprogram_specification() <SEMICOLON>
}

void subprogram_declarative_item() :
{}
{
    LOOKAHEAD( subprogram_declaration() )
    subprogram_declaration()
  | subprogram_body()
  | type_declaration()
  | subtype_declaration()
  | constant_declaration()
  | variable_declaration()
  | file_declaration()
  | alias_declaration()
  | LOOKAHEAD( attribute_declaration() ) attribute_declaration()
  | attribute_specification()
  | use_clause()
  | LOOKAHEAD( <GROUP> identifier() <IS> ) group_template_declaration()
  | group_declaration()
}

void subprogram_declarative_part() :
{}
{
  ( subprogram_declarative_item() )*
}

void subprogram_kind() :
{}
{
    <PROCEDURE>
  | <FUNCTION>
}

void subprogram_specification() :
{}
{
    <PROCEDURE> designator() [ <LPAREN> formal_parameter_list() <RPAREN> ]
  | [ <PURE> | <IMPURE> ]  <FUNCTION> designator() [ <LPAREN> formal_parameter_list() <RPAREN> ] <RETURN> type_mark()
}

void subprogram_statement_part() :
{}
{
  ( sequential_statement() )*
}

void suffix() :
{}
{
    simple_name()
  | <character_literal>
  | operator_symbol()
  | <ALL>
}

void target() :
{}
{
    name()
  | aggregate()
}

void term() :
{}
{
  factor() ( LOOKAHEAD( 2 ) multiplying_operator() factor() )*
}

void timeout_clause() :
{}
{
  <FOR> expression()
}

void use_clause() :
{}
{
   <USE> selected_name() ( <COMMA> selected_name() )* <SEMICOLON>
}

void variable_assignment_statement() :
{}
{
  [ LOOKAHEAD( label() <COLON> ) label() <COLON> ] target() <ASSIGN> expression() <SEMICOLON>
}

void variable_declaration() :
{}
{
  [ <SHARED> ] <VARIABLE> identifier_list() <COLON> subtype_indication() [ <ASSIGN> expression() ] <SEMICOLON>
}

void wait_statement() :
{}
{
  [ LOOKAHEAD( label() ) <COLON> label() <COLON>] <WAIT> [ sensitivity_clause() ] [ condition_clause() ] [ timeout_clause() ] <SEMICOLON>
}

void waveform() :
{}
{
    waveform_element() ( <COMMA> waveform_element() )*
  | <UNAFFECTED>
}

void waveform_element() :
{}
{
    LOOKAHEAD( <NULL> ) <NULL> [<AFTER> time_expression() ]
  | value_expression() [ <AFTER> time_expression() ]
}

/** Parts of grammar, which have to be checked during semantic analysis by semantic lookahead. */
void block_label() :
{}
{
  label()
}

void block_statement_label() :
{}
{
  label()
}

void case_label() :
{}
{
  label()
}

void generate_label() :
{}
{
  label()
}

void generate_statement_label() :
{}
{
  label()
}

void if_label() :
{}
{
  label()
}

void instantiation_label() :
{}
{
  label()
}

void loop_label() :
{}
{
  label()
}

void process_label() :
{}
{
  label()
}

void architecture_simple_name() :
{}
{
  simple_name()
}

void attribute_simple_name() :
{}
{
  simple_name()
  | <RANGE>
}

void component_simple_name() :
{}
{
  simple_name()
}

void configuration_simple_name() :
{}
{
  simple_name()
}

void element_simple_name() :
{}
{
  simple_name()
}

void entity_simple_name() :
{}
{
  simple_name()
}

void package_simple_name() :
{}
{
  simple_name()
}

void architecture_name() :
{}
{
  name()
}

void entity_name() :
{}
{
  name()
}

void file_name() :
{}
{
  name()
}

void function_name() :
{}
{
  name()
}

void configuration_name() :
{}
{
  name()
}

void component_name() :
{}
{
  name()
}

void generic_name() :
{}
{
  name()
}

void group_template_name() :
{}
{
  name()
}

void parameter_name() :
{}
{
  name()
}

void physical_type_simple_name() :
{}
{
  simple_name()
}

void port_name() :
{}
{
  name()
}

void procedure_name() :
{}
{
  name()
}

void range_attribute_name() :
{}
{
  name()
}

void signal_name() :
{}
{
  name()
}

void type_name() :
{}
{
  simple_name() [ LOOKAHEAD( name_extension() ) name_extension() ]
}

void record_type_simple_name() :
{}
{
  simple_name()
}

void resolution_function_name() :
{}
{
  name()
}

void unit_name() :
{}
{
  name()
}

void variable_name() :
{}
{
  name()
}

void architecture_identifier() :
{}
{
  identifier()
}

void static_expression() :
{}
{
  expression()
}

void boolean_expression() :
{}
{
  expression()
}

void file_open_kind_expression() :
{}
{
  expression()
}

void guard_expression() :
{}
{
  expression()
}

void time_expression() :
{}
{
  expression() // unit_name()
  // unit_name can be derived by expression!!!
}

void value_expression() :
{}
{
  expression()
}

void string_expression() :
{}
{
  expression()
}

void guarded_signal_list() :
{}
{
  signal_list()
}

void parameter_association_list() :
{}
{
  association_list()
}

void port_association_list() :
{}
{
  association_list()
}

void generic_association_list() :
{}
{
  association_list()
}

void parameter_interface_list() :
{}
{
  interface_list()
}

/** Controversial: */
void formal_port_clause() :
{}
{
  port_clause()
}

void local_port_clause() :
{}
{
  port_clause()
}

void formal_generic_clause() :
{}
{
  generic_clause()
}

void local_generic_clause() :
{}
{
  generic_clause()
}

void element_subtype_indication() :
{}
{
  subtype_indication()
}

void discrete_subtype_indication() :
{}
{
  subtype_indication()
}

void loop_parameter_specification() :
{}
{
  parameter_specification()
}

void generate_parameter_specification() :
{}
{
  parameter_specification()
}

void passive_concurrent_procedure_call_statement() :
{}
{
  concurrent_procedure_call_statement()
}

void passive_process_statement() :
{}
{
  process_statement()
}

void magnitude_simple_expression() :
{}
{
  simple_expression()
}

void phase_simple_expression() :
{}
{
  simple_expression()
}

/** Error recovery */
JAVACODE error_skipto error_skipto(int kind, String message)
{
  errorHandler.error(getToken(0), message);
  Token t;
  do {
    t = getNextToken();
  } while (t.kind != kind && t.next != null);
  return new error_skipto();
}
